{"version":3,"sources":["App.tsx","serviceWorker.ts","index.tsx"],"names":["useReducer","React","useEffect","useRef","useState","initialTimerState","breakLength","sessionLength","currentTime","started","paused","label","minutesToClock","minutes","date","Date","setMinutes","toISOString","substr","Display","timerState","id","className","reducerTimerState","state","action","type","timer","getTimeValues","toString","start","countdown","startValues","callback","dispatchTimerState","Error","Controls","audioRef","changeSegement","current","play","changeLabel","addEventListener","removeEventListener","timerStart","console","log","Button","onClick","pause","stop","dangerouslySetInnerHTML","__html","App","Timer","preload","ref","src","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"wPAMIA,EAAaC,IAAMD,WACnBE,EAAYD,IAAMC,UAClBC,EAASF,IAAME,OACfC,EAAWH,IAAMG,SAOfC,EAAoB,CACxBC,YAAa,EACbC,cAAe,GACfC,YAAa,QACbC,SAAS,EACTC,QAAQ,EACRC,MAAO,WA0BT,SAASC,EAAeC,GAEtB,IAAIC,EAAO,IAAIC,KAAK,GAEpB,OADAD,EAAKE,WAAWH,GACTC,EAAKG,cAAcC,OAAO,GAAI,GAQvC,SAASC,EAAT,GAA2D,IAAzCC,EAAwC,EAAxCA,WAChB,OACE,yBAAKC,GAAG,oBAAoBC,UAAU,aACpC,yBAAKD,GAAG,eAAc,4BAAKD,EAAWT,QACtC,yBAAKU,GAAG,aAAaD,EAAWZ,cAiBtC,SAASe,EAAkBC,EAAmBC,GAC5C,OAAQA,EAAOC,MACb,IAAK,iBACH,OAAIF,EAAMlB,YAzEK,IAyE0BkB,EAAMf,QACtC,2BAAKe,GAAZ,IAAmBlB,YAAakB,EAAMlB,YAAc,IAE/CkB,EACT,IAAK,iBACH,OAAIA,EAAMlB,YA7EK,KA6E0BkB,EAAMf,QACtC,2BAAKe,GAAZ,IAAmBlB,YAAakB,EAAMlB,YAAc,IAE/CkB,EACT,IAAK,mBACH,OAAIA,EAAMjB,cAjFO,IAiF4BiB,EAAMf,QAC1C,2BAAKe,GAAZ,IAAmBjB,cAAeiB,EAAMjB,cAAgB,EAAGC,YAAaI,EAAeY,EAAMjB,cAAgB,KAExGiB,EACT,IAAK,mBACH,OAAIA,EAAMjB,cArFO,KAqF4BiB,EAAMf,QAC7Ce,EAAMjB,cAAgB,IAAM,GACvB,2BAAKiB,GAAZ,IAAmBjB,cAAeiB,EAAMjB,cAAgB,EAAGC,YAAa,UAEjE,2BAAKgB,GAAZ,IAAmBjB,cAAeiB,EAAMjB,cAAgB,EAAGC,YAAaI,EAAeY,EAAMjB,cAAgB,KAG1GiB,EACT,IAAK,iBACH,OAAO,2BAAKA,GAAZ,IAAmBhB,YAAaiB,EAAOE,MAAMC,gBAAgBC,SAAS,CAAC,UAAW,cACpF,IAAK,aACH,OAAO,2BAAKL,GAAZ,IAAmBf,QAASgB,EAAOD,QACrC,IAAK,YACH,OAAO,2BAAKA,GAAZ,IAAmBd,OAAQe,EAAOD,QACpC,IAAK,aACH,OAAO,eAAKnB,GACd,IAAK,aAMH,OALAoB,EAAOE,MAAMG,MAAM,CACjBC,WAAW,EACXC,YAAa,CAAEnB,QAAyB,YAAhBW,EAAMb,MAAsBa,EAAMjB,cAAgBiB,EAAMlB,aAChF2B,SAAU,WAAQR,EAAOS,mBAAmB,CAAER,KAAM,iBAAkBC,MAAOF,EAAOE,WAE/EH,EACT,IAAK,cACH,GAAoB,YAAhBA,EAAMb,MACR,OAAO,2BAAKa,GAAZ,IAAmBb,MAAO,UACrB,GAAoB,UAAhBa,EAAMb,MACf,OAAO,2BAAKa,GAAZ,IAAmBb,MAAO,YAE5B,MAAM,IAAIwB,MAEZ,QACE,MAAM,IAAIA,OAWhB,SAASC,EAAT,GAA6F,IAA1EhB,EAAyE,EAAzEA,WAAWc,EAA8D,EAA9DA,mBAAmBP,EAA2C,EAA3CA,MAAMU,EAAqC,EAArCA,SACrDnC,GAAU,WAER,IAAMoC,EAAiB,WACG,OAArBD,EAASE,SACVF,EAASE,QAAQC,OAEjBC,EAAYd,IAKhB,OAFAA,EAAMe,iBAAiB,iBAAiBJ,GAEjC,WACLX,EAAMgB,oBAAoB,iBAAiBL,MAE5C,IAEH,IAkBMM,EAAa,SAACjB,GAClBkB,QAAQC,IAAI,cACZZ,EAAmB,CAAER,KAAM,aAAcC,MAAOA,EAAOO,mBAAoBA,IAC3EW,QAAQC,IAAI,iBAGRL,EAAc,SAACd,GACnBkB,QAAQC,IAAI,gBACZZ,EAAmB,CAAER,KAAM,gBAC3BkB,EAAWjB,IAYb,OACE,yBAAKN,GAAG,YACN,yBAAKA,GAAG,eAAR,SACA,yBAAKA,GAAG,eAAeC,UAAU,UAAUF,EAAWd,aACtD,yBAAKe,GAAG,iBAAR,WACA,yBAAKA,GAAG,iBAAiBC,UAAU,UAAUF,EAAWb,eACxD,yBAAKe,UAAU,UACb,kBAACyB,EAAD,CAAQ1B,GAAG,aAAaV,MAAQS,EAAWX,QAAiDW,EAAWV,OAAS,qCAAuC,sCAAlG,qCAAyIsC,QA9C1K,WACxBH,QAAQC,IAAI,yCAA2C1B,EAAWX,QAAU,wBAA0BW,EAAWV,SACtF,IAAvBU,EAAWX,SACboC,QAAQC,IAAI,SACZF,EAAWjB,GACXO,EAAmB,CAAER,KAAM,aAAcF,OAAO,IAChDqB,QAAQC,IAAI,YACoB,IAAvB1B,EAAWX,UAA0C,IAAtBW,EAAWV,QACnDmC,QAAQC,IAAI,SACZnB,EAAMsB,QACNf,EAAmB,CAAER,KAAM,YAAaF,OAAO,MACf,IAAvBJ,EAAWX,UAA0C,IAAtBW,EAAWV,SACnDmC,QAAQC,IAAI,WACZnB,EAAMG,QACNI,EAAmB,CAAER,KAAM,YAAaF,OAAO,QAiC7C,kBAACuB,EAAD,CAAQ1B,GAAG,QAAQV,MAAM,8BAA8BqC,QAjBxC,WACnBrB,EAAMuB,OACkB,OAArBb,EAASE,UACVF,EAASE,QAAQU,QACjBZ,EAASE,QAAQ/B,YAAc,GAEjC0B,EAAmB,CAAER,KAAM,mBAazB,kBAACqB,EAAD,CAAQ1B,GAAG,kBAAkBV,MAAM,6CAA6CqC,QAAS,kBAAMd,EAAmB,CAAER,KAAM,sBAC1H,kBAACqB,EAAD,CAAQ1B,GAAG,kBAAkBV,MAAM,2CAA2CqC,QAAS,kBAAMd,EAAmB,CAAER,KAAM,sBACxH,kBAACqB,EAAD,CAAQ1B,GAAG,oBAAoBV,MAAM,6CAA6CqC,QAAS,kBAAMd,EAAmB,CAAER,KAAM,wBAC5H,kBAACqB,EAAD,CAAQ1B,GAAG,oBAAoBV,MAAM,2CAA2CqC,QAAS,kBAAMd,EAAmB,CAAER,KAAM,yBAWhI,SAASqB,EAAT,GAAgE,IAA/C1B,EAA8C,EAA9CA,GAAGV,EAA2C,EAA3CA,MAAMqC,EAAqC,EAArCA,QACxB,OACE,yBAAK3B,GAAIA,EAAIC,UAAW,SAAU0B,QAASA,EAASG,wBAAyB,CAAEC,OAAQzC,KAK5E0C,MAnMf,WAAgB,IAAD,EACajD,EAAS,IAAIkD,KAD1B,mBACN3B,EADM,aAE4B3B,EAAWuB,EAAmBlB,IAF1D,mBAENe,EAFM,KAEMc,EAFN,KAGPG,EAAWlC,EAAyB,MAE1C,OACE,yBAAKkB,GAAG,aAAaC,UAAU,4CAC7B,kBAACH,EAAD,CAASC,WAAYA,IACrB,kBAACgB,EAAD,CAAUhB,WAAYA,EAAYc,mBAAoBA,EAAoBP,MAAOA,EAAOU,SAAUA,IAClG,2BAAOhB,GAAG,OAAOkC,QAAQ,OAAOC,IAAKnB,EAAUoB,IAAI,gHC/BrCC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACL9B,QAAQ8B,MAAMA,EAAMC,a","file":"static/js/main.07ab613f.chunk.js","sourcesContent":["import React from 'react';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './App.css';\n\nimport Timer from 'easytimer.js';\n\nlet useReducer = React.useReducer;\nlet useEffect = React.useEffect;\nlet useRef = React.useRef;\nlet useState = React.useState;\n\nconst BREAKMINIMUM = 1;\nconst BREAKMAXIMUM = 60;\nconst SESSIONMINIMUM = 1;\nconst SESSIONMAXIMUM = 60;\n\nconst initialTimerState = {\n  breakLength: 5,\n  sessionLength: 25,\n  currentTime: \"25:00\",\n  started: false,\n  paused: false,\n  label: \"SESSION\"\n};\n\ntype TimerState = {\n  breakLength: number;\n  sessionLength: number;\n  currentTime: string;\n  started: boolean;\n  paused: boolean;\n  label: string;\n}\n\nfunction App() {\n  const [timer, setTimer] = useState(new Timer());\n  const [timerState, dispatchTimerState] = useReducer(reducerTimerState, initialTimerState);\n  const audioRef = useRef<HTMLAudioElement>(null);\n\n  return (\n    <div id=\"timer-main\" className=\"my-3 p-3 bg-white shadow-lg container-sm\">\n      <Display timerState={timerState} />\n      <Controls timerState={timerState} dispatchTimerState={dispatchTimerState} timer={timer} audioRef={audioRef} />\n      <audio id=\"beep\" preload=\"auto\" ref={audioRef} src=\"https://raw.githubusercontent.com/freeCodeCamp/cdn/master/build/testable-projects-fcc/audio/BeepSound.wav\" />\n    </div>\n  );\n};\n\nfunction minutesToClock(minutes: number) {\n  //used to format the clock displays 00:00\n  let date = new Date(0);\n  date.setMinutes(minutes);\n  return date.toISOString().substr(14, 5);\n}\n\n\ntype displayProps = {\n  timerState: TimerState;\n}\n\nfunction Display({timerState}: displayProps): JSX.Element {\n  return (\n    <div id=\"display-container\" className=\"card my-3\">\n      <div id=\"timer-label\"><h1>{timerState.label}</h1></div>\n      <div id=\"time-left\">{timerState.currentTime}</div>\n    </div>\n  );\n};\n\ntype ACTIONTYPE =\n  | {type: \"breakDecrement\"}\n  | {type: \"breakIncrement\"}\n  | {type: \"sessionDecrement\"}\n  | {type: \"sessionIncrement\"}\n  | {type: \"setCurrentTime\"; timer:Timer}\n  | {type: \"setStarted\"; state:boolean}\n  | {type: \"setPaused\"; state:boolean }\n  | {type: \"setDefault\"}\n  | {type: \"timerStart\"; timer:Timer; dispatchTimerState: React.Dispatch<ACTIONTYPE>}\n  | {type: \"changeLabel\"};\n\nfunction reducerTimerState(state: TimerState, action: ACTIONTYPE): TimerState {\n  switch (action.type) {\n    case 'breakDecrement':\n      if (state.breakLength > BREAKMINIMUM && !state.started) {\n        return { ...state, breakLength: state.breakLength - 1 };\n      }\n      return state;\n    case 'breakIncrement':\n      if (state.breakLength < BREAKMAXIMUM && !state.started) {\n        return { ...state, breakLength: state.breakLength + 1 };\n      }\n      return state;\n    case 'sessionDecrement':\n      if (state.sessionLength > SESSIONMINIMUM && !state.started) {\n        return { ...state, sessionLength: state.sessionLength - 1, currentTime: minutesToClock(state.sessionLength - 1) };\n      }\n      return state;\n    case 'sessionIncrement':\n      if (state.sessionLength < SESSIONMAXIMUM && !state.started) {\n        if (state.sessionLength + 1 === 60) {// special case for 60 minutes\n          return { ...state, sessionLength: state.sessionLength + 1, currentTime: \"60:00\" };\n        } else {\n          return { ...state, sessionLength: state.sessionLength + 1, currentTime: minutesToClock(state.sessionLength + 1) };\n        }\n      }\n      return state;\n    case 'setCurrentTime':\n      return { ...state, currentTime: action.timer.getTimeValues().toString(['minutes', 'seconds']) };\n    case 'setStarted':\n      return { ...state, started: action.state };\n    case 'setPaused':\n      return { ...state, paused: action.state };\n    case 'setDefault':\n      return { ...initialTimerState };\n    case 'timerStart':\n      action.timer.start({\n        countdown: true,\n        startValues: { minutes: state.label === \"SESSION\" ? state.sessionLength : state.breakLength },\n        callback: () => { action.dispatchTimerState({ type: \"setCurrentTime\", timer: action.timer }) }\n      });\n      return state;\n    case 'changeLabel':\n      if (state.label === \"SESSION\") {\n        return { ...state, label: \"BREAK\" };\n      } else if (state.label === \"BREAK\") {\n        return { ...state, label: \"SESSION\" };\n      }\n      throw new Error();\n\n    default:\n      throw new Error();\n  }\n}\n\ntype controlProps = {\n  timerState: TimerState;\n  dispatchTimerState: React.Dispatch<ACTIONTYPE>;\n  timer: Timer;\n  audioRef: React.RefObject<HTMLAudioElement>;\n};\n\nfunction Controls({timerState,dispatchTimerState,timer,audioRef}:controlProps): JSX.Element {\n  useEffect(() => {\n    \n    const changeSegement = () => {\n      if(audioRef.current !== null){\n        audioRef.current.play(); //try to overcome ref could be null compile error, not sure if this is the best approach, change when understanding is better. Maybe have this check at the start?\n      }\n        changeLabel(timer);\n    }\n    \n    timer.addEventListener('targetAchieved',changeSegement);\n    // returned function will be called on component unmount \n    return () => {\n      timer.removeEventListener('targetAchieved',changeSegement);\n    }\n  }, []);\n\n  const startPauseCommand = () => {\n    console.log(\"startpausebutton, timerState.started: \" + timerState.started + \", timerState.paused: \" + timerState.paused);\n    if (timerState.started === false) {\n      console.log(\"start\");\n      timerStart(timer);\n      dispatchTimerState({ type: \"setStarted\", state: true });\n      console.log(\"start1\");\n    } else if (timerState.started === true && timerState.paused === false) {\n      console.log(\"pause\");\n      timer.pause();\n      dispatchTimerState({ type: \"setPaused\", state: true });\n    } else if (timerState.started === true && timerState.paused === true) {\n      console.log(\"restart\");\n      timer.start();\n      dispatchTimerState({ type: \"setPaused\", state: false });\n    }\n  }\n\n  const timerStart = (timer:Timer) => {\n    console.log(\"timerstart\");\n    dispatchTimerState({ type: \"timerStart\", timer: timer, dispatchTimerState: dispatchTimerState });\n    console.log(\"timerstart1a\");\n  }\n\n  const changeLabel = (timer:Timer) => {\n    console.log(\"timer change\");\n    dispatchTimerState({ type: \"changeLabel\"});\n    timerStart(timer);\n  }\n\n  const resetCommand = () => {\n    timer.stop();\n    if(audioRef.current !== null){ //is audio doesn't load then it doesn't play\n      audioRef.current.pause();\n      audioRef.current.currentTime = 0;\n    }\n    dispatchTimerState({ type: \"setDefault\"});\n  }\n\n  return (\n    <div id=\"controls\">\n      <div id=\"break-label\">Break</div>\n      <div id=\"break-length\" className=\"length\">{timerState.breakLength}</div>\n      <div id=\"session-label\">Session</div>\n      <div id=\"session-length\" className=\"length\">{timerState.sessionLength}</div>\n      <div className=\"center\">\n        <Button id=\"start_stop\" label={!timerState.started ? '<i class=\"fas fa-play-circle\"></i>' : timerState.paused ? '<i class=\"fas fa-play-circle\"></i>' : '<i class=\"fas fa-pause-circle\"></i>'} onClick={startPauseCommand} />\n        <Button id=\"reset\" label='<i class=\"fas fa-undo\"></i>' onClick={resetCommand} />\n      </div>\n      <Button id=\"break-decrement\" label='<i class=\"fas fa-chevron-circle-down\"></i>' onClick={() => dispatchTimerState({ type: \"breakDecrement\" })} />\n      <Button id=\"break-increment\" label='<i class=\"fas fa-chevron-circle-up\"></i>' onClick={() => dispatchTimerState({ type: \"breakIncrement\" })} />\n      <Button id=\"session-decrement\" label='<i class=\"fas fa-chevron-circle-down\"></i>' onClick={() => dispatchTimerState({ type: \"sessionDecrement\" })} />\n      <Button id=\"session-increment\" label='<i class=\"fas fa-chevron-circle-up\"></i>' onClick={() => dispatchTimerState({ type: \"sessionIncrement\" })} />\n    </div>\n  );\n}\n\ntype buttonProps = {\n  id:string;\n  label: string;\n  onClick(event: React.MouseEvent<HTMLElement>): void;\n};\n\nfunction Button({id,label,onClick}: buttonProps) : JSX.Element {\n  return (\n    <div id={id} className={\"button\"} onClick={onClick} dangerouslySetInnerHTML={{ __html: label }}>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}