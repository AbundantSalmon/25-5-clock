{"version":3,"sources":["Display.tsx","Buttons.tsx","Controls.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Display","timerState","id","className","label","currentTime","Button","onClick","dangerouslySetInnerHTML","__html","useEffect","React","Controls","dispatchTimerState","timer","audioRef","changeSegement","current","play","changeLabel","addEventListener","removeEventListener","timerStart","console","log","type","breakLength","sessionLength","started","paused","state","pause","start","stop","useReducer","useRef","useState","initialTimerState","minutesToClock","minutes","date","Date","setMinutes","toISOString","substr","reducerTimerState","action","getTimeValues","toString","countdown","startValues","callback","Error","App","Timer","preload","ref","src","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.eee49962.chunk.js","sourcesContent":["import React from 'react';\nimport './Display.css';\n\ntype displayProps = {\n    timerState: TimerState;\n}\n\nexport function Display({ timerState }: displayProps): JSX.Element {\n    return (\n        <div id=\"display-container\" className=\"card my-3\">\n            <div id=\"timer-label\"><h1>{timerState.label}</h1></div>\n            <div id=\"time-left\">{timerState.currentTime}</div>\n        </div>\n    );\n};","import React from 'react';\nimport './Buttons.css';\n\ntype buttonProps = {\n    id: string;\n    label: string;\n    onClick(event: React.MouseEvent<HTMLElement>): void;\n};\n\nexport function Button({ id, label, onClick }: buttonProps): JSX.Element {\n    return (\n        <div id={id} className={\"button\"} onClick={onClick} dangerouslySetInnerHTML={{ __html: label }}>\n        </div>\n    );\n}","import React from 'react';\nimport Timer from 'easytimer.js';\nimport {Button} from './Buttons';\nimport './Controls.css';\n\nlet useEffect = React.useEffect;\n\ntype controlProps = {\n    timerState: TimerState;\n    dispatchTimerState: React.Dispatch<ACTIONTYPE>;\n    timer: Timer;\n    audioRef: React.RefObject<HTMLAudioElement>;\n};\n\nexport function Controls({ timerState, dispatchTimerState, timer, audioRef }: controlProps): JSX.Element {\n    useEffect(() => {\n\n        const changeSegement = () => {\n            if (audioRef.current !== null) {\n                audioRef.current.play(); //try to overcome ref could be null compile error, not sure if this is the best approach, change when understanding is better. Maybe have this check at the start?\n            }\n            changeLabel(timer);\n        }\n\n        timer.addEventListener('targetAchieved', changeSegement);\n        // returned function will be called on component unmount \n        return () => {\n            timer.removeEventListener('targetAchieved', changeSegement);\n        }\n    }, []);\n\n    const startPauseCommand = () => {\n        console.log(\"startpausebutton, timerState.started: \" + timerState.started + \", timerState.paused: \" + timerState.paused);\n        if (timerState.started === false) {\n            console.log(\"start\");\n            timerStart(timer);\n            dispatchTimerState({ type: \"setStarted\", state: true });\n            console.log(\"start1\");\n        } else if (timerState.started === true && timerState.paused === false) {\n            console.log(\"pause\");\n            timer.pause();\n            dispatchTimerState({ type: \"setPaused\", state: true });\n        } else if (timerState.started === true && timerState.paused === true) {\n            console.log(\"restart\");\n            timer.start();\n            dispatchTimerState({ type: \"setPaused\", state: false });\n        }\n    }\n\n    const timerStart = (timer: Timer) => {\n        console.log(\"timerstart\");\n        dispatchTimerState({ type: \"timerStart\", timer: timer, dispatchTimerState: dispatchTimerState });\n        console.log(\"timerstart1a\");\n    }\n\n    const changeLabel = (timer: Timer) => {\n        console.log(\"timer change\");\n        dispatchTimerState({ type: \"changeLabel\" });\n        timerStart(timer);\n    }\n\n    const resetCommand = () => {\n        timer.stop();\n        if (audioRef.current !== null) { //is audio doesn't load then it doesn't play\n            audioRef.current.pause();\n            audioRef.current.currentTime = 0;\n        }\n        dispatchTimerState({ type: \"setDefault\" });\n    }\n\n    return (\n        <div id=\"controls\">\n            <div id=\"break-label\">Break</div>\n            <div id=\"break-length\" className=\"length\">{timerState.breakLength}</div>\n            <div id=\"session-label\">Session</div>\n            <div id=\"session-length\" className=\"length\">{timerState.sessionLength}</div>\n            <div className=\"center\">\n                <Button id=\"start_stop\" label={!timerState.started ? '<i class=\"fas fa-play-circle\"></i>' : timerState.paused ? '<i class=\"fas fa-play-circle\"></i>' : '<i class=\"fas fa-pause-circle\"></i>'} onClick={startPauseCommand} />\n                <Button id=\"reset\" label='<i class=\"fas fa-undo\"></i>' onClick={resetCommand} />\n            </div>\n            <Button id=\"break-decrement\" label='<i class=\"fas fa-chevron-circle-down\"></i>' onClick={() => dispatchTimerState({ type: \"breakDecrement\" })} />\n            <Button id=\"break-increment\" label='<i class=\"fas fa-chevron-circle-up\"></i>' onClick={() => dispatchTimerState({ type: \"breakIncrement\" })} />\n            <Button id=\"session-decrement\" label='<i class=\"fas fa-chevron-circle-down\"></i>' onClick={() => dispatchTimerState({ type: \"sessionDecrement\" })} />\n            <Button id=\"session-increment\" label='<i class=\"fas fa-chevron-circle-up\"></i>' onClick={() => dispatchTimerState({ type: \"sessionIncrement\" })} />\n        </div>\n    );\n}","import React from 'react';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './App.css';\n\nimport Timer from 'easytimer.js';\nimport {Display} from './Display';\nimport {Controls} from './Controls';\n\nlet useReducer = React.useReducer;\nlet useRef = React.useRef;\nlet useState = React.useState;\n\nconst BREAKMINIMUM = 1;\nconst BREAKMAXIMUM = 60;\nconst SESSIONMINIMUM = 1;\nconst SESSIONMAXIMUM = 60;\n\nconst initialTimerState = {\n  breakLength: 5,\n  sessionLength: 25,\n  currentTime: \"25:00\",\n  started: false,\n  paused: false,\n  label: \"SESSION\"\n};\n\nfunction App() {\n  const [timer, setTimer] = useState(new Timer());\n  const [timerState, dispatchTimerState] = useReducer(reducerTimerState, initialTimerState);\n  const audioRef = useRef<HTMLAudioElement>(null);\n\n  return (\n    <div id=\"timer-main\" className=\"my-3 p-3 bg-white shadow-lg container-sm\">\n      <Display timerState={timerState} />\n      <Controls timerState={timerState} dispatchTimerState={dispatchTimerState} timer={timer} audioRef={audioRef} />\n      <audio id=\"beep\" preload=\"auto\" ref={audioRef} src=\"https://raw.githubusercontent.com/freeCodeCamp/cdn/master/build/testable-projects-fcc/audio/BeepSound.wav\" />\n    </div>\n  );\n};\n\nfunction minutesToClock(minutes: number) {\n  //used to format the clock displays 00:00\n  let date = new Date(0);\n  date.setMinutes(minutes);\n  return date.toISOString().substr(14, 5);\n}\n\nfunction reducerTimerState(state: TimerState, action: ACTIONTYPE): TimerState {\n  switch (action.type) {\n    case 'breakDecrement':\n      if (state.breakLength > BREAKMINIMUM && !state.started) {\n        return { ...state, breakLength: state.breakLength - 1 };\n      }\n      return state;\n    case 'breakIncrement':\n      if (state.breakLength < BREAKMAXIMUM && !state.started) {\n        return { ...state, breakLength: state.breakLength + 1 };\n      }\n      return state;\n    case 'sessionDecrement':\n      if (state.sessionLength > SESSIONMINIMUM && !state.started) {\n        return { ...state, sessionLength: state.sessionLength - 1, currentTime: minutesToClock(state.sessionLength - 1) };\n      }\n      return state;\n    case 'sessionIncrement':\n      if (state.sessionLength < SESSIONMAXIMUM && !state.started) {\n        if (state.sessionLength + 1 === 60) {// special case for 60 minutes\n          return { ...state, sessionLength: state.sessionLength + 1, currentTime: \"60:00\" };\n        } else {\n          return { ...state, sessionLength: state.sessionLength + 1, currentTime: minutesToClock(state.sessionLength + 1) };\n        }\n      }\n      return state;\n    case 'setCurrentTime':\n      return { ...state, currentTime: action.timer.getTimeValues().toString(['minutes', 'seconds']) };\n    case 'setStarted':\n      return { ...state, started: action.state };\n    case 'setPaused':\n      return { ...state, paused: action.state };\n    case 'setDefault':\n      return { ...initialTimerState };\n    case 'timerStart':\n      action.timer.start({\n        countdown: true,\n        startValues: { minutes: state.label === \"SESSION\" ? state.sessionLength : state.breakLength },\n        callback: () => { action.dispatchTimerState({ type: \"setCurrentTime\", timer: action.timer }) }\n      });\n      return state;\n    case 'changeLabel':\n      if (state.label === \"SESSION\") {\n        return { ...state, label: \"BREAK\" };\n      } else if (state.label === \"BREAK\") {\n        return { ...state, label: \"SESSION\" };\n      }\n      throw new Error();\n\n    default:\n      throw new Error();\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}